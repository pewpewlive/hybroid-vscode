{
  "scopeName": "scope.hybroid",
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
  "name": "Hybroid",
  "patterns": [
    { "include": "#single_strings" },
    { "include": "#double_strings" },
    { "include": "#block-comments" },
    { "include": "#single_comments" },
    { "include": "#keywords" },
    { "include": "#constants" },
    { "include": "#function-call" },
    { "include": "#function-name" },
    { "include": "#function-arguments" },
    { "include": "#number" }
  ],
  "repository": {
    "block-comments": {
      "comment": "block comments",
      "name": "comment.block.hybroid",
      "begin": "(/\\*)",
      "end": "(\\*/)"
    },
    "function-call": {
      "name": "meta.function-call.hybroid",
      "comment": "Regular function call of the type \"name(args)\"",
      "begin": "(?x)\n  \\b(?=\n    ([[:alpha:]_]\\w*) \\s* (\\()\n  )\n",
      "end": "(\\))",
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.arguments.end.hybroid"
        }
      },
      "patterns": [
        {
          "include": "#function-name"
        },
        {
          "include": "#function-arguments"
        }
      ]
    },
    "function-name": {
      "patterns": [
        {
          "comment": "Some color schemas support meta.function-call.generic scope",
          "name": "meta.function-call.generic.hybroid",
          "match": "(?x)\n  \\b ([[:alpha:]_]\\w*) \\b\n"
        }
      ]
    },
    "function-arguments": {
      "begin": "(\\()",
      "end": "(?=\\))(?!\\)\\s*\\()",
      "beginCaptures": {
        "1": {
          "name": "punctuation.definition.arguments.begin.hybroid"
        }
      },
      "contentName": "meta.function-call.arguments.hybroid",
      "patterns": [
        {
          "name": "punctuation.separator.arguments.hybroid",
          "match": "(,)"
        },
        {
          "match": "(?x)\n  (?:(?<=[,(])|^) \\s* (\\*{1,2})\n",
          "captures": {
            "1": {
              "name": "keyword.operator.unpacking.arguments.hybroid"
            }
          }
        },
        {
          "match": "\\b([[:alpha:]_]\\w*)\\s*(=)(?!=)",
          "captures": {
            "1": {
              "name": "variable.parameter.function-call.hytbroid"
            },
            "2": {
              "name": "keyword.operator.assignment.hybroid"
            }
          }
        },
        {
          "name": "keyword.operator.assignment.hybroid",
          "match": "=(?!=)"
        },
        {
          "match": "\\s*(\\))\\s*(\\()",
          "captures": {
            "1": {
              "name": "punctuation.definition.arguments.end.hybroid"
            },
            "2": {
              "name": "punctuation.definition.arguments.begin.hybroid"
            }
          }
        }
      ]
    },
    "keywords": {
      "patterns": [
        {
          "name": "keyword.control.hybroid",
          "match": "(by|add|fn|tick|repeat|for|while|if|else|env|return|break|continue|let|new|pub|const|in|as|to|with|enum|use|spawn|struct|entity|find|remove|match|yield|from)"
        },
        {
          "name": "storage.type.hybroid",
          "match": "(number|fixed|bool|text)"
        },
        {
          "name": "variable.language.hybroid",
          "match": "(self)"
        },
        {
          "comment": "logical operators",
          "name": "keyword.operator.logical.hybroid",
          "match": "(or|and|not)(?!=)"
        },
        {
          "comment": "assignment operators",
          "name": "keyword.operator.assignment.hybroid",
          "match": "(\\+=|-=|\\*=|/=|%=|\\^=|\\|=)"
        },
        {
          "comment": "single equal",
          "name": "keyword.operator.assignment.equal.hybroid",
          "match": "(?<![<>])=(?!=|>)"
        },
        {
          "comment": "comparison operators",
          "name": "keyword.operator.comparison.hybroid",
          "match": "(=(=)?(?!>)|!=|<=|(?<!=)>=)"
        },
        {
          "comment": "math operators",
          "name": "keyword.operator.math.hybroid",
          "match": "(?<!\/)(?<!\/\/)(?<!\/\\*)(\\+=|\\-=|\\*=|\\\/=|\\^=|%=|(?<!\\\/\\*)\/|(?<!\\\/)\\\/|\\+|\\-|\\*|\\^|%)(?!\/)(?!\/\/)"
        }
      ]
    },
    "single_strings": {
      "name": "string.quoted.single.hybroid",
      "begin": "'",
      "end": "'",
      "patterns": [
        {
          "name": "constant.character.escape.hybroid",
          "match": "\\\\."
        }
      ]
    },
    "double_strings": {
      "name": "string.quoted.double.hybroid",
      "begin": "\"",
      "end": "\"",
      "patterns": [
        {
          "name": "constant.character.escape.hybroid",
          "match": "\\\\."
        }
      ]
    },
    "number": {
      "name": "constant.numeric.hybroid",
      "patterns": [
        {
          "include": "#number-float"
        },
        {
          "include": "#number-dec"
        },
        {
          "include": "#number-hex"
        },
        {
          "include": "#number-oct"
        },
        {
          "include": "#number-bin"
        },
        {
          "include": "#number-long"
        }
      ]
    },
    "number-float": {
      "name": "constant.numeric.float.hybroid",
      "match": "(?x)\n  (?<! \\w)(?:\n    (?:\n      \\.[0-9](?: _?[0-9] )*\n      |\n      [0-9](?: _?[0-9] )* \\. [0-9](?: _?[0-9] )*\n      |\n      [0-9](?: _?[0-9] )* \\.\n    ) (?: [eE][+-]?[0-9](?: _?[0-9] )* )?\n    |\n    [0-9](?: _?[0-9] )* (?: [eE][+-]?[0-9](?: _?[0-9] )* )\n  )([jJ])?\\b\n",
      "captures": {
        "1": {
          "name": "storage.type.imaginary.number.hybroid"
        }
      }
    },
    "number-dec": {
      "name": "constant.numeric.dec.hybroid",
      "match": "(?x)\n  (?<![\\w\\.])(?:\n      [1-9](?: _?[0-9] )*\n      |\n      0+\n      |\n      [0-9](?: _?[0-9] )* ([jJ])\n      |\n      0 ([0-9]+)(?![eE\\.])\n  )\\b\n",
      "captures": {
        "1": {
          "name": "storage.type.imaginary.number.hybroid"
        },
        "2": {
          "name": "invalid.illegal.dec.hybroid"
        }
      }
    },
    "number-hex": {
      "name": "constant.numeric.hex.hybroid",
      "match": "(?x)\n  (?<![\\w\\.])\n    (0[xX]) (_?[0-9a-fA-F])+\n  \\b\n",
      "captures": {
        "1": {
          "name": "storage.type.number.hybroid"
        }
      }
    },
    "number-oct": {
      "name": "constant.numeric.oct.hybroid",
      "match": "(?x)\n  (?<![\\w\\.])\n    (0[oO]) (_?[0-7])+\n  \\b\n",
      "captures": {
        "1": {
          "name": "storage.type.number.hybroid"
        }
      }
    },
    "number-bin": {
      "name": "constant.numeric.bin.hybroid",
      "match": "(?x)\n  (?<![\\w\\.])\n    (0[bB]) (_?[01])+\n  \\b\n",
      "captures": {
        "1": {
          "name": "storage.type.number.hybroid"
        }
      }
    },
    "number-long": {
      "name": "constant.numeric.bin.hybroid",
      "match": "(?x)\n  (?<![\\w\\.])\n    ([1-9][0-9]* | 0) ([lL])\n  \\b\n",
      "captures": {
        "2": {
          "name": "storage.type.number.hybroid"
        }
      }
    },
    "single_comments": {
      "name": "comment.line.double-slash.hybroid",
      "begin": "//",
      "end": "\n"
    },
    "constants": {
      "name": "constant.language.hybroid",
      "match": "\\b(true|false)\\b"
    }
  }
}
